---

title: JVM-高频面试题
icon: article
date: 2024-03-21
category: JVM
tag:
  - 面试

---

## 1、类的生命周期

一个类完整的生命周期，会经历五个阶段，分别为：**加载、连接、初始化、使用**、和**卸载**。其中的连接又分为**验证、准备**和**解析**三个步骤

### 加载（Loading）

简单一句话概括，类的加载阶段就是：**找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口**。结合jvm的内存结构会比较好理解。

这里要区别一下接触到的类加载。类加载其实包括加载、连接、初始化三个阶段。类加载强调一个jvm能够直接使用所需的类，所以类必须完成初始化。

不同的虚拟机对类的加载时机有不同的实现方式，具体要看虚拟机的实现方式。这里不做展开。

类的加载方式比较灵活，总结下来有如下几种：

1. 据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；（常用）
2. 从jar文件中读取。另外，还有下面几种方式也比较常用：（常用）
3. 从网络中获取：比如10年前十分流行的Applet。
4. 根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。
5. 从非class文件中获取，其实这与直接从class文件中获取的方式本质

### 连接（Linking）

1. **验证**：进行类的合法性校验。会对比如字节码格式、变量与方法的合法性、数据类型的有效性、继承与实现的规范性等等进行检查，确保别加载的类能够正常的被jvm所正常运行。
2. **准备**：为类的静态变量分配内存，并设为jvm默认的初值；对于非静态的变量，则不会为它们分配内存。简单说就是**分内存、赋初值**。注意：设置初始值为jvm默认初值，而不是程序设定。规则如下
   - 基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0
   - 引用类型的默认值为null
   - 常量的默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。
3. **解析**：这一阶段的任务就是把常量池中的符号引用转换为直接引用。

- 

### 初始化(Initialization)

类初始化阶段是**类加载**过程的最后一步。而也是到了该阶段，才真正开始执行类中定义的java程序代码(字节码)，之前的动作都由虚拟机主导。

jvm对类的加载时机没有明确规范，但对类的初始化时机有：**只有当类被直接引用的时候，才会触发类的初始化。**类被直接引用的情况有以下几种：

1. 通过以下几种方式：
   - new关键字创建对象
   - 读取或设置类的静态变量
   - 调用类的静态方法
2. 通过反射方式执行1里面的三种方式；
3. 初始化子类的时候，会触发父类的初始化；
4. 作为程序入口直接运行时（调用main方法）；
5. 接口实现类初始化的时候，会触发直接或间接实现的所有接口的初始化。

- 

关于类的初始化，记住两句话

1、类的初始化，会**自上而下运行**静态代码块或静态赋值语句，非静态与非赋值的静态语句均不执行。

2、如果存在父类，则父类先进行初始化，是一个典型的**递归**模型。

区别于**对象的初始化**，类的初始化所做的一起都是基于类变量或类语句的，也就是说执行的都是共性的抽象信息。而我们知道，类就是对象实例的抽象。



### 使用（Using）

类的使用分为**直接引用**和**间接引用**。

直接引用与间接引用等判别条件，是看对该类的引用是否会引起类的初始化

直接引用已经在类的初始化中的有过阐述，不再赘述。而类的间接引用，主要有下面几种情况：

1. 当引用了一个类的静态变量，而该静态变量继承自父类的话，不引起初始化
2. 定义一个类的数组，不会引起该类的初始化；
3. 当引用一个类的的常量时，不会引起该类的初始化



### 卸载（(Unloading）

当类使用完了之后，类就要进入卸载阶段了。那何为衡量类使用完的标准呢？

1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。



## 2、类加载器， JVM类加载机制

![](./images.assets/58d39c4085603513a6b29e935c4ed2f.png)

上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器

- 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等

- 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包

- 应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类

- 自定义加载器：负责加载用户自定义路径下的类包

  

**JDK8以后废弃扩展类加载器（Extension ClassLoader）的原因**

JDK8以后，使用平台类加载器（Platform ClassLoader）替换了原来的扩展类加载器（Extension ClassLoader）。有两个基本的原因归纳如下：

在JDK8中的这个Extension ClassLoader，主要用于加载jre环境下的lib下的ext下的jar包。当想要扩展Java的功能的时候，把jar包放到这个ext文件夹下。然而这样的做法并不安全，不提倡使用。

这种扩展机制被**JDK9开始加入的“模块化开发”**的天然的扩展能力所取代。

总之，扩展能力被取代了又不安全，所以被废弃。



## 3、能说一下JVM的内存区域吗？



![](./images.assets/20210305173849710.png)

**1、程序计数器**

程序计数器（Program Counter Register）也被称为**PC寄存器**，是一块较小的内存空间。

它可以看作是**当前线程所执行的字节码的行号指示器**。

**2、Java虚拟机栈**

Java虚拟机栈（Java Virtual Machine Stack）**也是线程私有的，它的生命周期与线程相同**

**作用**：主管 Java 程序的运行，它保存方法的**局部变量、部分结果，并参与方法的调用和返回**。

**特点**：

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着**入栈**（进栈/压栈），方法执行结束**出栈**
- **栈不存在垃圾回收问题**

**栈中可能出现的异常**：

Java 虚拟机规范允许 **Java虚拟机栈的大小是动态的或者是固定不变的**

- 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 **StackOverflowError** 异常
- 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常

可以通过参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 

**3、本地方法栈**

- Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用
- 本地方法栈也是线程私有的
- 允许线程固定或者可动态扩展的内存大小
- 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常
- 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个OutofMemoryError异常
- 本地方法是使用 C 语言实现的
- 它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。
- 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存
- 并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈
- 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一 

**4、Java堆**

对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**，Java里“**几乎**”所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是Java虚拟机规范本身制定的。

**5.方法区**

- 方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。
- 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。
- **运行时常量池**（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。
- 方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误
- JVM 关闭后方法区即被释放 

## 4、对象创建的过程了解吗？

 虚拟机收到new指令触发。

类加载检查：如果类没有被类加载器加载，则执行类加载流程（将class信息加载到JVM的运行时数据区的过程），对象所需内存大小在类加载完后可以完全确定。

对象分配内存：从堆中划分出一块确定大小的内存。

内存空间初始化：内存分配完后，虚拟机需要将分配到的内存空间初始化为零值（如：int值为0，boolean值为false等），保证了对象的实例字段在Java代码中可以直接使用。

为对象进行必要的设置：虚拟机为对象进行设置，如设置对象属于哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中。

从虚拟机的角度来看，一个新的对象已经创建完毕。但从Java程序的角度来看，对象创建才刚开始，所有的字段还是零值，所以需要程序员进行初始化操作，这样一个真正可用的对象才算完全产生出来。

init是对对象级别的变量或非静态代码块进行初始化的

clinit静态变量或者静态代码块谁来初始化呢

## 5、对象内存分配方式

虚拟机为新对象分配内存，从堆中划出一块确定大小的内存，因为对象所需内存的大小在类加载完后可以完全确定。

堆内存是否规整：

![](./images.assets/2024032115571100.png)

- 堆内存规整：已使用的内存在一边，未使用内存在另一边。
- 堆内存不规整：已使用内存和未使用相互交错。

堆内存是否规整是由垃圾收集器是否带有压缩整理功能决定的。

**内存分配方式：**

分配方式的选择 取决于 Java堆内存是否规整：

![](./images.assets/c1281dc551694b49862edaf1acb96b77.png)

- 空闲列表：

- - 堆内存不规整。
  - 分配过程：虚拟机内部维护了一个记录可用内存块的列表，在分配时从列表找一块足够大的空间划分给对象实例，并更新列表上的记录。

Java堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定

## 6、JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？

对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全。

**解决线程安全问题有两种方案：**

![](./images.assets/2024032116011201.png)

- 采用CAS分配重试的方式来保证更新操作的原子性
- 每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。-XX:+UseTLAB

虚拟机1.8默认使用的是 TLAB 方式来进行内存分配的，如果想要使用CAS方式，可以通过设置 -XX：-UseTLAB 参数来关闭TLAB功能即可。默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 -XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小。如果通过TLAB分配失败的时候，则会回到Eden区通过 CAS 方式进行分配。

## 7、对象的内存布局

在Java虚拟机（HotSpot）中，对象在 Java 内存中的 存储布局 可分为三块：

1. 对象头 存储区域
2. 实例数据 存储区域
3. 对齐填充 存储区域

**对象头区域：**

![](./images.assets/2024032116051241.png)

存储对象自身的运行时数据，如：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。

存储对象类型指针，即对象指向类元数据的指针，JVM可以确定这个对象属于哪个类的实例。

如果是数组，对象头中还有一块记录数组长度的数据。

**实例数据区域：**

- 代码中定义的字段内容。

**对齐填充区域：**

- 占位符。
- 非必须。

说明：占位符起占位作用，因为对象的大小必须是8字节的整数倍，而因HotSpot VM的要求对象起始地址必须是8字节的整数倍，且对象头部分正好是8字节的倍数。因此，当对象实例数据部分没有对齐时（即对象的大小不是8字节的整数倍），就需要通过对齐填充来补全。

## 8.内存泄漏可能由哪些原因导致呢？

**静态集合类引起内存泄漏**

静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。

```java
public class OOM {
    static List list = new ArrayList();

    public void oomTests(){
        Object obj = new Object();

        list.add(obj);
    }
}
```

**单例模式**

和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。

**数据连接、IO、Socket等连接**

创建的连接不再使用时，需要调用 **close** 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。

**变量不合理的作用域**

一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。

**hash值发生变化**

对象Hash值改变，使用HashMap、HashSet等容器中时候，由于对象修改之后的Hah值和存储进容器时的Hash值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么String类型被设置成了不可变类型。

**ThreadLocal使用不当**

ThreadLocal的弱引用导致内存泄漏也是个老生常谈的话题了，使用完ThreadLocal一定要记得使用remove方法来进行清除。

## 9.如何判断对象仍然存活？

**1、reference count（引用计数）**

**引用计数法**会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

引用计数法的优点是实现简单，缺点有两点：

1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。



**2、Root Searching（根可达算法或根搜索算法）**

**所谓的“根”即是**：所有的程序都是从 main 方法来运行，在 main 方法里面 new 出来的对象即为根对象。

**例如**：在 main 方法里面我们 new 了一个 list 集合，在 list 集合中我们又可以存放若干其他对象，那我们就称 list 为根对象，我们顺着根的数据结构往下走，只要存在引用指向的对象，那该对象就不是垃圾，反之不存在引用的对象，那该对象就是垃圾。

**根对象（root）的类型**

根对象不仅仅包括我们上面所说的 main 方法里面的对象，属于根对象的还有以下这些：

可以作为GC Roots的主要有四种对象：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象

- - 比如:各个线程被调用的方法中使用到的参数、局部变量等（局部变量表）。	

- 方法区中类静态属性引用的对象

- - 比如: Java类的引用类型静态变量

- 方法区中常量引用的对象

- - 比如:字符串常量池(String Table)里的引用

- 所有被同步锁synchroni zed持有的对象

## 10.垃圾收集算法了解吗？

垃圾收集算法主要有三种：

1. **标记-清除算法**

   见名知义，标记-清除（Mark-Sweep）算法分为两个阶段：

   - **标记** : 标记出所有需要回收的对象
   - **清除**：回收所有被标记的对象

   标记-清除算法比较基础，但是主要存在两个缺点：

   - 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
   - 内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

2. **标记-复制算法**

   标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。

   过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

   这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。

   新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。

3. **标记-整理算法**

为了降低内存的消耗，引入一种针对性的算法：标记-整理（Mark-Compact）算法。

其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要Stop The World才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。

## 11. 三色标记算法了解吗

三色标记算法:

1.用于垃圾回收器升级，将STW变为并发标记。STW就是在标记垃圾的时候，必须暂停程序，而使用并发标记，就是程序一边运行，一边标记垃圾。

2.避免重复扫描对象，提升标记阶段的效率

**什么是三色：**

首先我们需要知道**三色标记法就是根据可达性分析**，**从GC Roots开始进行遍历访问**，在遍历对象过程中，按“是否检查过”这个条件将对象标记成三种颜色：

**白色**：该对象没有被标记过。（对象垃圾）

**灰色**：该对象已经被标记过了，但该对象下的属性没有全被标记完。（GC需要从此对象中去寻找垃圾）

**黑色**：该对象已经被标记过了，且该对象下的属性也全部都被标记过了。（程序所需要的对象）

![](./images.assets/三色标记查找过程.gif)

假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：

初始时，所有对象都在【白色集合】中；

将 GC Roots直接引用到的对象挪到【灰色集合】中；

从灰色集合中获取对象：

3.1. 将本对象引用到的其他对象全部挪到【灰色集合】中； 

3.2. 将本对象挪到【黑色集合】里面。

重复步骤3，直至【灰色集合】为空时结束。

结束后，仍在【白色集合】的对象即为GC Roots不可达，可以进行回收。

需要注意，传统标记方式发生Stop The World时，对象间的引用是不会发生变化的，可以轻松完成标记。

而并发标记在标记期间应用线程还在继续跑，对象间的引用可能发生变化，就会出现错标和漏标的情况就有可能发生。

**存在的问题**

- **浮动垃圾**：并发标记的过程中，若一个已经被标记成黑色或者灰色的对象，突然变成了垃圾，由于不会再对黑色标记过的对象重新扫描,所以不会被发现，那么这个对象不是白色的但是不会被清除，重新标记也不能从GC Root中去找到，所以成为了浮动垃圾，**浮动垃圾对系统的影响不大，留给下一次GC进行处理即可**。

- **对象漏标问题**（需要的对象被回收）：并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用）（这两部可以不分先后顺序）；因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被GC回收，此问题会导致系统出现问题，而CMS与G1，两种回收器在使用三色标记法时，都采取了一些措施来应对这些问题，**CMS对增加引用环节进行处理（Increment Update），G1则对删除引用环节进行处理(SATB)。**

总结

三色标记算法是根可达算法的一种实现方案，其目的是为了找出所有可达对象。三色标记算法会产生多标和漏标问题，其中漏标问题最严重。漏标问题会导致本该存活的对象被回收，从而导致严重的程序问题。

## 12.能详细说一下CMS收集器的垃圾收集过程吗？

CMS收集齐的垃圾收集分为四步：

- **初始标记**（CMS initial mark）：单线程运行，需要Stop The World，标记GC Roots能直达的对象。	
- **并发标记**（（CMS concurrent mark）：无停顿，和用户线程同时运行，从GC Roots直达对象开始遍历整个对象图。
- **重新标记**（CMS remark）：多线程运行，需要Stop The World，标记并发标记阶段产生对象。
- **并发清除**（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。

Concurrent Mark Sweep收集器运行示意图如下：

![](./images.assets/20231031122057.png)

参数：-XX:+UseConcMarkSweepGC

| 回收年代和算法      | 优点                                            | 缺点                                        | 适用场景                                                     |
| ------------------- | ----------------------------------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 老年代,标记清除算法 | 系统由于垃圾回收出现的停 顿时间较短，用户体验好 | 1、内存碎片问题 2、退化问题 3、浮动垃圾问题 | 大型的互联网系统中用户请求数 据量大、频率高的场景 比如订单接口、商品接口等 |

CMS垃圾回收器存在的问题

缺点：

1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。 这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之 后再整理。

2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。

4、并发阶段会影响用户线程执行的性能

## 13.G1垃圾收集器了解吗？

Garbage First（简称G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于Region的内存布局形式。

虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。

**G1把连续的Java堆划分为多个大小相等的独立区域（****Region****）**，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。

**更精细的控制、可预测的停顿时间、内存碎片的控制、优先级处理**

![](./images.assets/20240124105832.png)

参数1： -XX:+UseG1GC 打开G1的开关， JDK9之后默认不需要打开

参数2：-XX:MaxGCPauseMillis=毫秒值 最大暂停的时间

G1收集器的运行过程大致可划分为以下四个步骤：

- **初始标记**（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。
- **并发标记**（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、
- **最终标记**（Remark），STW，标记再并发标记过程中产生的垃圾。= 重新标记（标记的范围更小）
- **筛选回收**（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。需要STW。

## 14.有了CMS，为什么还要引入G1？

优点：CMS最主要的优点在名字上已经体现出来——并发收集、低停顿。

缺点：CMS同样有三个明显的缺点。

- Mark Sweep算法会导致内存碎片比较多
- CMS的并发能力比较依赖于CPU资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。
- 并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。

G1主要解决了内存碎片过多的问题。

## 15.你们线上用的什么垃圾收集器？为什么要用它？

**常见的垃圾回收器:**

**新生代收集器(高吞吐量)：** Serial、ParNew、Parallel Scavenge

**老年代收集器（SWT停顿时间）：** Serial Old、CMS、Parallel Old

**新生代和老年代收集器：** G1、ZGC、Shenandoah

每种垃圾回收器之间不是独立操作的，下图表示垃圾回收器之间有连线表示，可以协作使用：

![](./images.assets/20210403210732814.png)

一般的[垃圾回收器](https://so.csdn.net/so/search?q=垃圾回收器&spm=1001.2101.3001.7020)搭配为：

- Serial New（复制算法。单线程，不能利用多核） + Serial Old（标记整理。单线程） (Serial系列是单线程，GC时stop the world)  **JDK 5 版本之前**

**JDK8 ：**

- ParNew（复制算法。并行。 单核情况下不如Serial） + CMS（标记清除。并发） 

- - **适合类型**：适用于需要低停顿时间的应用，如 Web 服务器、应用服务器。
  - **示例应用**：电商网站、在线游戏、高并发服务器。
  - **4-8G可以用ParNew+CMS**

- Parallel Scavenge（复制算法。并行，吞吐量优先收集器） + Parallel Old（标记整理。并行）

- - **适合类型**：适用于多核处理器的高吞吐量应用。
  - **示例应用**：科学计算、数据分析、大规模数据处理。
  - **4G以下可以用parallel** 

- G1 （年轻代：复制 老年代：标记-整理）**JDK 9 默认的收集器** 要求尽可能可控 GC 停顿时间；内存占用较大的应用。

- - **适合类型**：适用于需要可预测停顿时间的应用，尤其是大堆内存的应用。
  - **示例应用**：企业级应用、中大规模 Web 服务、应用响应时间要求高的系统。
  - **8G以上可以用G1**

zgc:适用于需要极低停顿时间（毫秒级别）的大内存应用

- - **适合类型**：适用于需要极低停顿时间（毫秒级别）的大内存应用。
  - **示例应用**：内存密集型数据库、金融交易系统、云服务。
  - **几百G以上用ZGC** 

- 

怎么查默认用的GC是什么呢？

可以使用命令：

```plain
java -XX:+PrintCommandLineFlags -version
```

可以看到有这么一行：

```plain
-XX:+UseParallelGC
```

UseParallelGC = Parallel Scavenge + Parallel Old，表示的是新生代用的Parallel Scavenge收集器，老年代用的是Parallel Old 收集器。

那为什么要用这个呢？默认的呗。

当然面试肯定不能这么答。

Parallel Scavenge的特点是什么？

高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用Parallel Scavenge + Parallel Old的组合。

当然，这个默认虽然也有说法，但不太讨喜。

还可以说：

采用Parallel New+CMS的组合，我们比较关注服务的响应速度，所以采用了CMS来降低停顿时间。

或者一步到位：

我们线上采用了设计比较优秀的G1垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了CMS的浮动垃圾问题、内存碎片问题。

## 16.垃圾收集器应该如何选择？

垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用JDK的发行商是什么？等等……

这里简单地列一下上面提到的一些收集器的适用场景：

- Serial ：如果应用程序有一个很小的内存空间（大约100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。
- Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受1秒或更长的停顿时间。
- CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约1秒以内。
- ZGC：如果响应时间是高优先级的，或者堆空间比较大。

## 17.对象一定分配在堆中吗？有没有了解逃逸分析技术？

**对象一定分配在堆中吗？** 不一定的。

随着JIT编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。

**什么是逃逸分析？**

**逃逸分析**是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。

通俗点讲，当一个对象被new出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。-xx: -DoEscapeAnalysis 

![](./images.assets/2024032210241201.png)

除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。

```java
public class Main {
    private static Object sharedObj;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                sharedObj = new Object(); // 一个对象被创建并赋值给共享变量
            }
        });

        thread.start();

        thread.join(); // 等待线程执行结束

        System.out.println(sharedObj.toString());
    }
}
```



**逃逸分析的好处**

- 栈上分配

如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。

- **同步消除**

线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。

- **标量替换**

如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个Java对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。

## 18.了解哪些性JVM监控和故障处理工具？

以下是一些JDK自带的可视化性能监控和故障处理工具：

- JConsole

Jconsole 是一个**内置 Java 性能分析器**，是基于Java Management Extensions (JMX)的实时图形化监测工具，这个工具利用了内建到JVM里面的JMX指令来对Java进程提供实时的性能和资源的监控。其监控内容包括：内存、线程、类、CPU使用(Java进程的内存使用，线程的状态，类的使用)等。通过监控信息，可以很清晰的了解到**当前程序是否运行正常，如内存泄露、死锁、类加载异常等**。

备注:Jconsole管理内存**相当于可视化的jstat命令**

![](./images.assets/2024032210311201.png)

开启远程：

java -jar  xxx.jar

- -Dcom.sun.management.jmxremote 远程开启开关
- -Dcom.sun.management.jmxremote.port=1808 jmx远程调用端口
- -Dcom.sun.management.jmxremote.authenticate=false 不开启验证
- -Dcom.sun.management.jmxremote.ssl=false 不为ssl连接
- -Djava.rmi.server.hostname=34.126.141.21 服务器所在ip或者域名

![](./images.assets/2024032210321452.png)

- VisualVM（jvisualvm）	

VisualVM 是一款免费的，集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 **Java 应用程序做性能分析和调优**。这些功能包括生成和**分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析** .

![](./images.assets/2024032210331203.png)

- **jps** 

- - 查看java进程

- **jstat** 

- - jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用形式： 
  - jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]
  - 如：jstat-gc 13616 100 8；
  - 常用参数：
    - - - -class (类加载器)
        - -compiler (JIT)
        - -gc (GC 堆状态)
        - -gccapacity (各区大小)
        - -gccause (最近一次 GC 统计和原因)
        - -gcnew (新区统计)
        - -gcnewcapacity (新区大小)
        - -gcold (老区统计)
        - gcoldcapacity (老区大小)
        - gcpermcapacity (永久区大小)
        - gcutil (GC 统计汇总)
        - printcompilation (HotSpot 编译统计)
        - - 

jmap

○jmap用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。

■heap : 显示Java堆详细信息

■histo : 显示堆中对象的统计信息

■permstat :Java堆内存的永久保存区域的类加载器的统计信息

■finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行 finalizer方法的对象

■dump : 生成堆转储快照

```te
jmap -dump:file=d:\user.hprof 1246
```

- **jstack**

jstack [vmid]
jstack用于生成虚拟机当前时刻的线程快照。
线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。

一般来说 jstack 主要是用来排查是否有死锁和某个进程的线程调用栈的情况

除此之外，还有一些第三方的工具

- **MAT**Java 堆内存分析工具。

  ![](./images.assets/2024032210532010.png)

- **GCViewer**   GC 日志分析工具。

  ![](./images.assets/5bb16b0a0001e4a510240541.jpg)

- **arthas**阿里开源诊断工具。

## 19.JVM的常见参数配置知道哪些？

- 参数1 ： -Xmx 和 –Xms

  -Xmx参数设置的是最大堆内存，但是由于程序是运行在服务器或者容器上，计算可用内存时，要将元空间、操作系统、 其它软件占用的内存排除掉。

  案例： 服务器内存4G，操作系统+元空间最大值+其它软件占用1.5G，-Xmx可以设置为2g。

  最合理的设置方式应该是根据最大并发量估算服务器的配置，然后再根据服务器配置计算最大堆内存的值。

  建议将-Xms设置的和-Xmx一样大,运行过程中不再产生扩容的开销。

- 参数2 ： -XX:MaxMetaspaceSize 和 -Xss

  -XX:MaxMetaspaceSize=值 参数指的是最大元空间大小，默认值比较大，如果出现元空间内存泄漏会让操作系 统可用内存不可控，建议根据测试情况设置最大值，一般设置为256m。

  -Xss256k 栈内存大小，如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计 算机的体系结构。比如Linux x86 64位 ： 1MB，如果不需要用到这么大的栈内存，完全可以将此值调小节省内存 空间，合理值为256k – 1m之间。

- 参数3： -Xmn

  -Xmn 年轻代的大小，默认值为整个堆的1/3，可以根据峰值流量计算最大的年轻代大小，尽量让对象只存放在年 轻代，不进入老年代。但是实际的场景中，接口的响应时间、创建对象的大小、程序内部还会有一些定时任务等不 确定因素都会导致这个值的大小并不能仅凭计算得出，如果设置该值要进行大量的测试。G1垃圾回收器尽量不要设 置该值，G1会动态调整年轻代的大小。

- 打印GC日志

  JDK8及之前 ： -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径

  JDK9及之后 ： -Xlog:gc*:file=文件路径

- -XX:+DisableExplicitGC

  禁止在代码中使用System.gc()， System.gc()可能会引起FULLGC，在代码中尽量不要使用。使用 DisableExplicitGC参数可以禁止使用System.gc()方法调用。

- -XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemoryError错误时，自动生成hprof内存快照文件。 -XX:HeapDumpPath=：指定hprof文件的输出路径。

JVM参数模板：

| -Xms1g                                       | 初始堆内存1g                    |
| -------------------------------------------- | ------------------------------- |
| -Xmx1g                                       | 最大堆内存1g                    |
| -Xss256k                                     | 每个线程的栈内存最大256k        |
| -XX:MaxMetaspaceSize=512m                    | 最大元空间大小512m              |
| -XX:+DisableExplicitGC                       | 代码中System.gc()无效           |
| -XX:+HeapDumpOnOutOfMemoryError              | OutOfMemory错误时生成堆内存快照 |
| -XX:HeapDumpPath=/opt/dumps/my-service.hprof | 堆内存快照生成位置              |
| -XX:+PrintGCDetails                          | 打印详细垃圾回收日志            |
| -XX:+PrintGCDateStamps                       | 打印垃圾回收时间                |
| -Xloggc:文件路径                             | 日志文件输出位置                |

注意： JDK9及之后gc日志输出修改为 -Xlog:gc*:file=文件名

堆内存大小和栈内存大小根据实际情况灵活调整。

## 20.有没有进行过JVM调优，说说你的调优思路？

**为什么要调优**

- 防止出现OOM
- 解决OOM
- 减少Full GC出现的频率

前面铺垫了很多JVM的基础知识，这一讲我们终于来到了JVM调优课题。JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：

- 大多数的Java应用不需要进行JVM优化； 
- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）； 
- 上线之前，应先考虑将机器的JVM参数设置到最优； 
- 减少创建对象的数量（代码层面）； 
- 减少使用全局变量和大对象（代码层面）； 
- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）； 
- 分析GC情况优化代码比优化JVM参数更好（代码层面）； 

通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。接下来我们再看看如何进行JVM调优，调优不是盲目的，我们每修改一个JVM都有它背后的考究和数据支撑。在这里分享给大家一个比较通用的JVM调优的步骤 ⬇️

### JVM调优的一般步骤为：

- 第1步：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；
- 第2步：确定JVM调优量化目标；
- 第3步：确定JVM调优参数（根据历史JVM参数来调整）；
- 第4步：调优一台服务器，对比观察调优前后的差异；
- 第5步：不断的分析和调整，直到找到合适的JVM参数配置；
- 第6步：找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。

### 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点

前面提到每一个参数的修改都有它背后的数据做支撑。那数据是怎么来的呢？就是从我们`GC`日志和`dump`文件中分析出来的。这一讲我们就来仔细聊一聊我们通过什么工具去查看GC日志和dump文件，如何去分析GC日志和dump文件去找出症节所在。

#### GC日志分析

首先我们来看看GC日志分析，可能很多同学都没看到过GC日志，GC日志记录了垃圾收集器的运行情况，包括垃圾回收的原因、时间、执行的线程、回收的内存空间等信息。它主要用于分析垃圾收集器的性能和调优，在这里我们先来铺垫一下我们的工程是如何获取到GC日志的，然后我们在去讲工具讲分析。这里我们以Java程序、Tomcat项目、SpringBoot项目来讲解。

**Java程序**

Java程序可以通过在启动参数中添加相应的参数来开启GC日志的记录。具体而言，可以使用以下参数：

- -XX:+PrintGC：开启GC日志输出；
- -XX:+PrintGCDetails：在GC日志中输出详细的信息；
- -XX:+PrintGCDateStamps：在GC日志中输出时间戳；
- -Xlog:gc+heap=trace：在GC前后输出堆的详细信息；

```
-Xlog:gc:<filename>：将GC日志输出到指定的文件中。
```



基于Java17版本：

例如，可以使用如下命令启动Java程序，并输出GC日志到文件gc.log中：

```bash
-Xms5M -Xmx5M -Xlog:gc:/Users/a123/IdeaProjects/java-example/logs/gc.log -XX:+PrintGC -Xlog:gc+heap=trace
```

在程序运行过程中，GC日志会被输出到指定的文件中，可以通过分析日志来了解垃圾收集的情况，进而进行优化和调优。

**Tomcat**

对于Tomcat项目，可以在Tomcat启动脚本中的JAVA_OPTS变量中添加相应的参数来开启GC日志的记录。具体而言，可以修改catalina.sh或catalina.bat（Windows下）文件，加入如下参数：

```bash
JAVA_OPTS="-Xloggc:/path/to/gc.log -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC"
```

其中，/path/to/gc.log为指定的日志输出文件路径。

**SpringBoot**

对于Spring Boot项目，可以在application.properties或application.yml配置文件中添加以下参数：

```properties
logging.file=gc.log
logging.level.gc=info
```

其中，logging.file指定日志文件名，logging.level.gc指定日志输出级别，这里设置为info以输出GC日志。

需要注意的是，不同版本的Tomcat和Spring Boot可能会有所差异，具体添加参数的方式可能会有所不同。在实际使用中，应该查阅对应版本的文档或手册，了解如何正确地开启GC日志记录。

我们简单的来看一下GC日志：

```bash
[2023-02-14T22:13:12.554+0800] -XX:+PrintGC is deprecated. Will use -Xlog:gc instead.
[2023-02-14T22:13:12.557+0800] Using G1
[2023-02-14T22:13:12.593+0800] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 3M->3M(8M) 1.720ms
[2023-02-14T22:13:12.596+0800] GC(1) Pause Young (Concurrent Start) (G1 Preventive Collection) 4M->3M(8M) 1.533ms
[2023-02-14T22:13:12.596+0800] GC(2) Concurrent Mark Cycle
[2023-02-14T22:13:12.598+0800] GC(3) Pause Young (Normal) (G1 Preventive Collection) 4M->4M(8M) 1.069ms
[2023-02-14T22:13:12.601+0800] GC(4) To-space exhausted
[2023-02-14T22:13:12.601+0800] GC(4) Pause Young (Normal) (G1 Preventive Collection) 5M->5M(8M) 2.454ms
[2023-02-14T22:13:12.606+0800] GC(5) To-space exhausted
[2023-02-14T22:13:12.606+0800] GC(5) Pause Young (Normal) (G1 Evacuation Pause) 6M->6M(8M) 4.494ms
[2023-02-14T22:13:12.617+0800] GC(6) Pause Full (G1 Compaction Pause) 6M->6M(8M) 10.797ms
[2023-02-14T22:13:12.627+0800] GC(7) Pause Full (G1 Compaction Pause) 6M->6M(8M) 10.258ms
[2023-02-14T22:13:12.627+0800] GC(2) Concurrent Mark Cycle 31.610ms
[2023-02-14T22:13:12.628+0800] GC(8) Pause Young (Normal) (G1 Evacuation Pause) 6M->6M(8M) 0.243ms
[2023-02-14T22:13:12.636+0800] GC(9) Pause Full (G1 Compaction Pause) 6M->6M(8M) 8.079ms
[2023-02-14T22:13:12.646+0800] GC(10) Pause Full (G1 Compaction Pause) 6M->6M(8M) 10.570ms
[2023-02-14T22:13:12.647+0800] GC(11) Pause Young (Concurrent Start) (G1 Evacuation Pause) 6M->6M(8M) 0.307ms
[2023-02-14T22:13:12.647+0800] GC(13) Concurrent Mark Cycle
[2023-02-14T22:13:12.648+0800] GC(12) Pause Full (G1 Compaction Pause) 6M->1M(8M) 1.330ms
[2023-02-14T22:13:12.648+0800] GC(13) Concurrent Mark Cycle 1.388ms
```

日志文件直接看起来不是不是很直观看起来比较费劲。事实上分析GC日志可视化的工具很多很多，这里整理了一份：

- GCViewer：功能简单、易于使用，适合初学者。
- GCEasy：自动检测GC日志，并提供了一系列的报告和建议，适合快速定位和解决GC问题。
- HPROF：Java自带的堆内存分析工具，可以与GCViewer等工具结合使用，提供更全面的分析。
- Java Mission Control：JDK自带的性能监控工具，提供了包括GC在内的多种监控指标，并能与VisualVM等工具集成使用。
- VisualVM：功能全面、插件丰富，支持多种监控指标和分析方式，适合高级用户和专业人士。
- GClogAnalyzer：提供了多种图表和分析工具，能够深入分析GC日志的各个方面。
- YourKit Java Profiler：功能丰富、易于使用，提供了GC分析、CPU分析、内存分析等多种功能，适合专业人士使用。
- JProfiler：提供了多种性能分析和调试工具，包括GC分析、CPU分析、内存分析等，适合专业人士使用。

在此我们基于GCEasy来进行GC日志分析。

官网地址为：https://gceasy.io/ 它有在线分析版和离线分析版都可以使用

![](./images.assets/2024032211141201.png)

![](./images.assets/2024023311141520.png)

查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。

**举一个例子： 系统崩溃前的一些现象：**

-  每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5s
-  FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC
-  年老代的内存越来越大并且每次FullGC后年老代没有内存被释放

之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。

#### dump文件分析

讲完了我们的GC日志分析，我们再来看看我们的dump文件分析，dump文件记录了Java虚拟机在某个时间点的状态信息，包括Java虚拟机进程的堆栈信息、Java对象的详细信息、线程信息、类信息等。它主要用于分析Java虚拟机的状态、诊断内存泄漏等问题。GC日志适合用于调优垃圾收集器，而dump文件适合用于分析Java虚拟机的状态信息。

**分析结果，判断是否需要优化**

如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

**如果满足下面的指标，则一般不需要进行GC：**

-  Minor GC执行时间不到50ms；
-  Minor GC执行不频繁，约10秒一次；
-  Full GC执行时间不到1s；
-  Full GC执行频率不算频繁，不低于10分钟1次；

**调整GC类型和内存分配**

如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。

**不断的分析和调整**

通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些**参数应用到所有服务器。**

### 有用过哪些JVM调优参数吗？

1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，**为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;**

**2.年轻代和年老代将根据默认的比例（1：2）分配堆内存**， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

3.年轻代和年老代设置多大才算合理

**1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC**

**2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率**

如何选择应该依赖应用程序**对象生命周期的分布情况**： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。

**在抉择时应该根 据以下两点：**

（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。

（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。

**4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法**： **-XX:+UseParallelOldGC** **。**

**5.线程堆栈的设置**：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。

理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

## 21.线上服务CPU占用过高怎么排查？

问题分析：CPU高一定是某个程序长期占用了CPU资源。

1、所以先需要找出那个进程占用CPU高。

- top  列出系统各个进程的资源占用情况。

2、然后根据找到对应进行里哪个线程占用CPU高。

- top -Hp 进程ID   列出对应进程里面的线程占用资源情况

3、找到对应线程ID后，再打印出对应线程的堆栈信息

- printf "%x\n"  PID    把线程ID转换为16进制。
- jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。

4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。

查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。



也可以用Arthas排查定位问题

**Arthas** 是阿里开源的 Java 诊断工具，相比 JDK 内置的诊断工具，要更人性化，并且功能强大，可以实现许多问题的一键定位，而且可以一键反编译类查看源码，甚至是直接进行生产代码热修复，实现在一个工具内快速定位和修复问题的一站式服务。

Arthas 官方文档： [alibaba.github.io/arthas/](https://link.juejin.cn?target=https%3A%2F%2Falibaba.github.io%2Farthas%2F)

### 启动 Arthas

首先，下载 Arthas： [arthas.aliyun.com/arthas-boot…](https://link.juejin.cn?target=https%3A%2F%2Farthas.aliyun.com%2Farthas-boot.jar)

然后把程序先运行起来，再运行 arthas：java -jar arthas-boot.jar

启动后，直接找到我们要排查的 JVM 进程，然后可以看到 Arthas 附加进程成功：

![](./images.assets/2024032211261205.png)

输入 help 命令，可以看到所有支持的命令列表。这里主要会用到 dashboard、thread、jad、watch 等命令，来定位高CPU的问题。

![](./images.assets/2024032211277520.png)

### dashboard — 展示整体情况

`dashboard` 命令整体展示了进程所有线程、内存、GC 等情况，可以明显看到两个CPU占用很高的线程，从线程名字来看应该是线程池的线程。

![](./images.assets/2024032211281023.png)

### thread — 查看高CPU的线程

接下来，查看最繁忙的线程在执行的线程栈，可以使用 thread -n 命令。这里，我们查看下最忙的 2 个线程：从线程栈可以看出，应该就是 CpuService 的 randomEncode 方法调用 BCryptPasswordEncoder 的 encode 方法导致CPU负载高的。

![](./images.assets/2024032211293210.png)

### watch — 监控参数

如果想要观察方法的入参和出参，可以用 watch 命令来观察：

![](./images.assets/2024032211304250.png)

### jad — 反编译

![](./images.assets/2024032211315203.png)

### redefine — 重载类

如果我们想做线上调试，又不想在本地改代码，打印日志，再提交到服务器，再重启服务测试，那我们可以结合 arthas 的 jad、mc、redefine 来动态重定义类。

1、首先用 jad 把源文件下载下来

![](./images.assets/2024032211321054.png)

然后修改下源码：添加了一行输出日志

![](./images.assets/2024032211332302.png)

2、使用 mc 命令反编译源文件

反编译后会生成对应的 class 文件：

![](./images.assets/2024032211331025.png)

3、使用 redefine 重载类

![](./images.assets/2024032211345630.png)

就可以看到控制台已经在输出我们打印的日志了

需要额外说明的是，由于 monitor、trace、watch 等命令是通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此诊断结束要执行 shutdown 来还原类或方法字节码，然后退出 Arthas。

## 22.内存飙高问题怎么排查？

分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。

1、先观察垃圾回收的情况

- jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。
- jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。

如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。

2、导出堆内存文件快照

- jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。

如果会挂掉

```plain
-XX:+HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=/crashes/my-heap-dump.hprof
```

3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。

## 23.频繁 minor gc 怎么办？

优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间-Xmn来降低Minor GC的频率。

## 24.频繁Full GC怎么办？

Full GC的排查思路大概如下：

1. 清楚从程序角度，有哪些原因导致FGC？

- **大对象**：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。
- **内存泄漏**：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.
- 程序频繁生成一些**长生命周期的对象**，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. 
- **程序BUG**
- 代码中**显式调用了gc**方法，包括自己的代码甚至框架中的代码。
- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。

1. 清楚排查问题时能使用哪些工具

- 公司的监控系统：大部分公司都会有，可全方位监控JVM的各项指标。
- JDK的自带工具，包括jmap、jstat等常用命令：

```plain
# 查看堆内存各区域的使用率以及GC情况
jstat -gcutil -h20 pid 1000
# 查看堆内存中的存活对象，并按空间排序
jmap -histo pid | head -n20
# dump堆内存文件
jmap -dump:format=b,file=heap pid
```

- 可视化的堆内存分析工具：JVisualVM、MAT等

1. 排查指南

- 查看监控，以了解出现问题的时间点以及当前FGC的频率（可对比正常情况看频率是否正常）
- 了解该时间点之前有没有程序上线、基础组件升级等情况。
- 了解JVM的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析JVM参数设置是否合理。
- 再对步骤1中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用gc方法比较容易排查。
- 针对大对象或者长生命周期对象导致的FGC，可通过 jmap -histo 命令并结合dump堆内存文件作进一步分析，需要先定位到可疑对象。
- 通过可疑对象定位到具体代码再次分析，这时候要结合GC原理和JVM参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。

## 25.有没有处理过内存溢出(OOM)问题？是如何定位的？

对于排查 OOM 问题、分析程序堆内存使用情况，最好的方式就是分析堆转储，堆转储，包含了堆现场全貌和线程栈信息。这节就来看看如何使用MAT分析OOM问题。

### MAT 分析OOM问题的思路

对于线上运行的程序，如果我们不能通过日志快速定位出OOM的根源，一般就可以使用MAT来分析OOM的问题。

使用 MAT 分析 OOM 问题，一般可以按照以下思路进行：

- 通过支配树功能或直方图功能查看消耗内存最大的类型，来分析内存泄露的大概原因；
- 查看那些消耗内存最大的类型、详细的对象明细列表，以及它们的引用链，来定位内存泄露的具体点；
- 配合查看对象属性的功能，可以脱离源码看到对象的各种属性的值和依赖关系，帮助我们理清程序逻辑和参数；
- 辅助使用查看线程栈来看 OOM 问题是否和过多线程有关，甚至可以在线程栈看到 OOM 最后一刻出现异常的线程。

如果dump出来的内存快照很大，比如有几个G，务必在启动MAT之前，先在配置文件（MemoryAnalyzer.ini）里给MAT本身设置—下堆内存大小（默认为1024m），比如设置为4个G，或者8个G。

### 总览图 — 快速分析OOM问题

使用MAT打开堆转储文件 dump.hprof，打开后先进入的是概览信息界面：

从饼图可以看出，明显有对象占用了大量内存，然后再看 **Problem Suspect1**，已经说明了 main 线程通过局部变量占据了 99.42% 内存的对象，而且是 java.lang.Object[] 数组占据了大量内存。

![](./images.assets/2024032215402103.png)

点击 **Details** 进去查看详细的说明，从 “Accumulated Objects in Dominator Tree” 支配树可以看出，main 线程引用了 OomService 对象，OomService 引用了一个 ArrayList 对象，然后 ArrayList 存储了大量 String 对象。这里基本上就能分析出OOM的根源了。

![](./images.assets/2024032215412581.png)

再点击 **See stacktrace** 看看线程栈基本就能定位到问题代码了。

![](./images.assets/2024032215432015.png)

### 直方图 — 定位根源

工具栏的第二个按钮可以打开直方图，直方图按照类型进行分组，列出了每个类有多少个实例，以及占用的内存。

可以看到，char[] 字节数组占用内存最多，对象数量也很多，第二位的 String 对象数量也非常多，有 9791 个，从这大概可以猜出应该是创建了大量的 String 对象。

![](./images.assets/2024032215436321.png)

在 char[] 上点击右键，选择 List objects -> with incoming references，就可以列出所有的 char[] 实例，以及每个 char[] 的整个引用关系链：

![](./images.assets/2024032215441782.png)

随机展开一个 char[]，如下图所示：

右侧框中可以看到整个引用链，左侧的框可以查看每一个实例的内部属性。

通过这个引用链可以发现是 String 对象引用了 byte[] 数组（String 的内部结构就是一个 byte[] 数组），说明创建了大量的 String 对象；然后 String 对象又被 ArrayList 的 Object[] 数组引用着，说明是大量 String 对象放入了 ArrayList 中。到这里就定位出了引发OOM的类了。

**Retained Heap（深堆）** 代表对象本身和对象关联的对象占用的内存，**Shallow Heap（浅堆）** 代表对象本身占用的内存。比如，OOMTest 中的这个 ArrayList 对象本身只有 24 字节，但是其所有关联的对象占用了大概5MB 内存。

![](./images.assets/2024032215451236.png)

如果希望看到完整内容的话，可以右键选择 Copy->Value，把值复制到剪贴板或保存到文件中：

![](./images.assets/2024032215468520.png)

### 线程栈 — 分析代码

可以点击工具栏的第五个按钮，打开线程视图来分析 OOMTest 执行什么逻辑。

![](./images.assets/2024032215478521.png)

